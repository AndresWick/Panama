/* 
	Trigger que se encargara de comprobar si existe algun pago para la reserva en la cual se desea modificar el costo
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: UPDATE
	TABLA:  Reserva
	COLUMNAS: v_costo	
	EXCEPTION: Si encuentra algun pago no puede cambiar el costo de la reserva
*/
CREATE OR REPLACE TRIGGER tg_compruebaPagos
	BEFORE UPDATE OF v_costo ON reserva
	FOR EACH ROW
	DECLARE
		lv_pagosRealizados number(3,0);
		le_pagoEcontrado EXCEPTION;			
	BEGIN
		SELECT COUNT(PR.k_id) INTO lv_pagosRealizados FROM pagoReserva PR WHERE PR.k_idReserva=:NEW.k_id;
		IF (lv_pagosRealizados > 0) THEN
			RAISE le_pagoEcontrado;
		END IF;		
	EXCEPTION
		WHEN le_pagoEcontrado THEN
			RAISE_APPLICATION_ERROR(-20600,'Ya se registra un pago para esa reserva');
		WHEN VALUE_ERROR THEN
			RAISE_APPLICATION_ERROR(-20601,'No se pudo identificar el numero de pagos realizados');
END tg_compruebaPagos;
/
/* 
	Si se inserta un costo en la reserva: Trigger que se encargara de crear un registro en la tabla resumenpagoreserva 
										  correspondiente a la nueva reserva
	Si se actualiza el costo en la reserva: Trigger que se encargara de actualizar el saldo pendiente para la tabla 
											resumenpagoreserva
	PRE-CONDICION: No se ha realizado ningun pago para la reserva
	TRIGGER TYPE: AFTER EACH ROW
	TRIGGERING EVENT: INSERT OR UPDATE
	TABLA:  Reserva
	COLUMNAS: v_costo
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/
CREATE OR REPLACE TRIGGER tg_insercionRmenPagoR
	AFTER INSERT OR UPDATE OF v_costo ON reserva
	FOR EACH ROW				
	BEGIN
		IF INSERTING THEN		
			INSERT INTO resumenPagoReserva (k_reserva, v_saldo_pendiente, f_ultimo_pago) VALUES (:NEW.k_id, :NEW.v_costo, NULL);
		ELSE
			UPDATE resumenPagoReserva  SET v_saldo_pendiente=:NEW.v_costo WHERE k_reserva = :NEW.k_id;
		END IF;		
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
END tg_insercionRmenPagoR;
/
/* 
	Trigger que se encargara de comprobar si el pago que se desea registrar es menor a la deuda que posee la reserva
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  pagoReserva
	COLUMNAS: cualquiera
	EXCEPTION:  Si el valor del pago es mayor a la deuda
				Si no encuentra un valor para la deuda
*/
CREATE OR REPLACE TRIGGER tg_comprobacionPagoReserva
	BEFORE INSERT ON pagoReserva
	FOR EACH ROW
	DECLARE
		lv_deuda resumenPagoReserva.v_saldo_pendiente%TYPE; 
		le_saldosobrepasado EXCEPTION;
	BEGIN
		SELECT RA.v_deuda INTO lv_deuda FROM reservasAgente RA WHERE RA.k_id = :NEW.k_idReserva;
  		IF(:NEW.v_valor > lv_deuda) THEN
  			RAISE le_saldosobrepasado;	
		END IF;
	EXCEPTION
		WHEN le_saldosobrepasado THEN
			RAISE_APPLICATION_ERROR(-20501,'El valor del saldo pendiente es menor al valor que se desea pagar');
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR(-20300,'Error al recuperar la deuda actual');
END tg_comprobacionPagoReserva;
/
/* 
	Trigger que se encargara de actualizar el saldo pendiente de la tabla resumenpagoreserva una vez se ha registrado
	un pago para la reserva
	TRIGGER TYPE: AFTER EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  pagoReserva
	COLUMNAS: cualquiera
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/
CREATE OR REPLACE TRIGGER tg_updateRmenPagoR
	AFTER INSERT ON pagoReserva
	FOR EACH ROW				
	BEGIN		
		UPDATE resumenPagoReserva SET v_saldo_pendiente = (v_saldo_pendiente - :NEW.v_valor), f_ultimo_pago = sysdate  WHERE k_reserva = :NEW.k_idReserva;		
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
END tg_updateRmenPagoR;
/
show errors

----------------------------------------------------------------
/* 
	Trigger que se encargara de comprobar si existe algun pago para el paso en el cual se desea modificar el costo
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: UPDATE
	TABLA:  paso
	COLUMNAS: v_costo	
	EXCEPTION: Si encuentra algun pago no puede cambiar el costo del paso
*/
CREATE OR REPLACE TRIGGER tg_compruebaPagosPaso
	BEFORE UPDATE OF v_costo ON paso
	FOR EACH ROW
	DECLARE
		lv_pagosRealizados number(3,0);
		le_pagoEncontrado EXCEPTION;			
	BEGIN
		SELECT COUNT(PP.k_id) INTO lv_pagosRealizados FROM pagoPaso PP WHERE PP.k_paso=:NEW.k_id;
		IF (lv_pagosRealizados > 0) THEN
			RAISE le_pagoEncontrado;
		END IF;		
	EXCEPTION
		WHEN le_pagoEncontrado THEN
			RAISE_APPLICATION_ERROR(-20700,'Ya se registra un pago para ese paso');
		WHEN VALUE_ERROR THEN
			RAISE_APPLICATION_ERROR(-20601,'No se pudo identificar el numero de pagos realizados');
END tg_compruebaPagosPaso;
/
/* 
	Si se inserta un costo en el paso:  Trigger que se encargara de crear un registro en la tabla resumenpagopaso 
										correspondiente al nuevo paso
	Si se actualiza el costo en un paso: Trigger que se encargara de actualizar el saldo pendiente para la tabla 
											resumenpagopaso
	PRE-CONDICION: No se ha realizado ningun pago para el paso
	TRIGGER TYPE: AFTER EACH ROW
	TRIGGERING EVENT: INSERT OR UPDATE
	TABLA:  paso
	COLUMNAS: v_costo
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/
CREATE OR REPLACE TRIGGER tg_insercionRmenPagoP
	AFTER INSERT OR UPDATE OF v_costo ON paso
	FOR EACH ROW				
	BEGIN
		IF INSERTING THEN		
			INSERT INTO resumenPagoPaso (k_paso, v_saldo_pendiente, f_ultimo_pago) VALUES (:NEW.k_id, :NEW.v_costo, NULL);
		ELSE
			UPDATE resumenPagoPaso  SET v_saldo_pendiente=:NEW.v_costo WHERE k_paso = :NEW.k_id;
		END IF;		
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
END tg_insercionRmenPagoP;
/
/* 
	Trigger que se encargara de comprobar si el pago que se desea registrar es menor a la deuda que posee el paso
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  pagoPaso
	COLUMNAS: cualquiera
	EXCEPTION:  Si el valor del pago es mayor a la deuda
				Si no encuentra un valor para la deuda
*/
CREATE OR REPLACE TRIGGER tg_comprobacionPagoPaso
	BEFORE INSERT ON pagoPaso
	FOR EACH ROW
	DECLARE
		lv_deuda resumenPagoPaso.v_saldo_pendiente%TYPE; 
		le_saldosobrepasado EXCEPTION;
	BEGIN
		SELECT PA.v_deuda INTO lv_deuda FROM pasosAgente PA WHERE PA.k_id = :NEW.k_paso;
  		IF(:NEW.v_valor > lv_deuda) THEN
  			RAISE le_saldosobrepasado;	
		END IF;
	EXCEPTION
		WHEN le_saldosobrepasado THEN
			RAISE_APPLICATION_ERROR(-20501,'El valor del saldo pendiente es menor al valor que se desea pagar');
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR(-20300,'Error al recuperar la deuda actual');
END tg_comprobacionPagoPaso;
/
/* 
	Trigger que se encargara de actualizar el saldo pendiente de la tabla resumenpagopaso una vez se ha registrado
	un pago para el paso
	TRIGGER TYPE: AFTER EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  pagoPaso
	COLUMNAS: cualquiera
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/
CREATE OR REPLACE TRIGGER tg_updateRmenPagoP
	AFTER INSERT ON pagoPaso
	FOR EACH ROW				
	BEGIN		
		UPDATE resumenPagoPaso SET v_saldo_pendiente = (v_saldo_pendiente - :NEW.v_valor), f_ultimo_pago = sysdate  WHERE k_paso = :NEW.k_paso;		
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
END tg_updateRmenPagoP;
/
show errors
/* 
	Trigger que se encargara de asegurar que el id del nuevo agente sea todo en mayusculas
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  agente
	COLUMNAS: cualquiera
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/
CREATE OR REPLACE TRIGGER tg_registroAgente
	BEFORE INSERT ON agente
	FOR EACH ROW
	BEGIN
		:NEW.k_id := UPPER(:NEW.k_id);
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
	
END tg_registroAgente;
/




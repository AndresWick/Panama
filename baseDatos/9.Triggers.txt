/* 
	Trigger que se encargara de comprobar si existe algun pago para la reserva en la cual se desea modificar el costo
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: UPDATE
	TABLA:  Reserva
	COLUMNAS: v_costo	
	EXCEPTION: Si encuentra algun pago no puede cambiar el costo de la reserva
*/
CREATE OR REPLACE TRIGGER tg_compruebaPagos
	BEFORE UPDATE OF v_costo ON reserva
	FOR EACH ROW
	DECLARE
		lv_pagosRealizados number(3,0);
		le_pagoEcontrado EXCEPTION;			
	BEGIN
		SELECT COUNT(PR.k_id) INTO lv_pagosRealizados FROM pagoReserva PR WHERE PR.k_idReserva=:NEW.k_id;
		IF (lv_pagosRealizados > 0) THEN
			RAISE le_pagoEcontrado;
		END IF;		
	EXCEPTION
		WHEN le_pagoEcontrado THEN
			RAISE_APPLICATION_ERROR(-20600,'Ya se registra un pago para esa reserva');
		WHEN VALUE_ERROR THEN
			RAISE_APPLICATION_ERROR(-20601,'No se pudo identificar el numero de pagos realizados');
END tg_compruebaPagos;
/
/* 
	Si se inserta un costo en la reserva: Trigger que se encargara de crear un registro en la tabla resumenpagoreserva 
										  correspondiente a la nueva reserva
	Si se actualiza el costo en la reserva: Trigger que se encargara de actualizar el saldo pendiente para la tabla 
											resumenpagoreserva
	PRE-CONDICION: No se ha realizado ningun pago para la reserva
	TRIGGER TYPE: AFTER EACH ROW
	TRIGGERING EVENT: INSERT OR UPDATE
	TABLA:  Reserva
	COLUMNAS: v_costo
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/

CREATE OR REPLACE TRIGGER tg_insercionRmenPagoR
	AFTER INSERT OR UPDATE OF v_costo ON reserva
	FOR EACH ROW
	DECLARE
		l_user varchar2(25);		
				 
		CURSOR C_columnas IS 
		  	SELECT COLUMN_NAME   FROM ALL_TAB_COLS
		  		WHERE TABLE_NAME =  'RESERVA' AND OWNER = 'CANALDEPANAMA';
		Rc_columna C_columnas%ROWTYPE;

		ln_columnvalue auditoria.va_nuevo%TYPE;				
	BEGIN
		SELECT user INTO l_user FROM DUAL;
		
		IF INSERTING THEN		
			INSERT INTO resumenPagoReserva (k_reserva, v_saldo_pendiente, f_ultimo_pago) VALUES (:NEW.k_id, :NEW.v_costo, NULL);
			OPEN C_columnas;
			LOOP
				FETCH C_columnas INTO Rc_columna;
				EXIT WHEN C_columnas%NOTFOUND;
					ln_columnvalue := Rc_columna.COLUMN_NAME;
					INSERT INTO auditoria (k_id, n_usuario,f_proceso,i_tipo,n_tabla,n_columna,va_anterior,va_nuevo) 
					VALUES (auditoria_seq.NEXTVAL,l_user,sysdate,'INSERT','RESERVA',ln_columnvalue,NULL,ln_columnvalue);					
						
			END LOOP;
			CLOSE C_columnas;
		ELSE
			UPDATE resumenPagoReserva  SET v_saldo_pendiente=:NEW.v_costo WHERE k_reserva = :NEW.k_id;
			INSERT INTO auditoria (k_id,n_usuario,f_proceso,i_tipo,n_tabla,n_columna,va_anterior,va_nuevo) 
					VALUES (auditoria_seq.NEXTVAL,l_user,sysdate,'UPDATE','RESERVA','V_COSTO',:OLD.V_COSTO,:NEW.V_COSTO);
		END IF;		
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
		WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR(-20302,SQLCODE);
END tg_insercionRmenPagoR;
/
/* 
	Trigger que se encargara de comprobar si el pago que se desea registrar es menor a la deuda que posee la reserva
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  pagoReserva
	COLUMNAS: cualquiera
	EXCEPTION:  Si el valor del pago es mayor a la deuda
				Si no encuentra un valor para la deuda
*/
CREATE OR REPLACE TRIGGER tg_comprobacionPagoReserva
	BEFORE INSERT ON pagoReserva
	FOR EACH ROW
	DECLARE
		lv_deuda resumenPagoReserva.v_saldo_pendiente%TYPE; 
		le_saldosobrepasado EXCEPTION;
	BEGIN
		SELECT RA.v_deuda INTO lv_deuda FROM reservasAgente RA WHERE RA.k_id = :NEW.k_idReserva;
  		IF(:NEW.v_valor > lv_deuda) THEN
  			RAISE le_saldosobrepasado;	
		END IF;
	EXCEPTION
		WHEN le_saldosobrepasado THEN
			RAISE_APPLICATION_ERROR(-20501,'El valor del saldo pendiente es menor al valor que se desea pagar');
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR(-20300,'Error al recuperar la deuda actual');
END tg_comprobacionPagoReserva;
/
/* 
	Trigger que se encargara de actualizar el saldo pendiente de la tabla resumenpagoreserva una vez se ha registrado
	un pago para la reserva
	TRIGGER TYPE: AFTER EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  pagoReserva
	COLUMNAS: cualquiera
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/
CREATE OR REPLACE TRIGGER tg_updateRmenPagoR
	AFTER INSERT ON pagoReserva
	FOR EACH ROW
	DECLARE
		l_user varchar2(25);
		lv_anterior resumenpagoreserva.v_saldo_pendiente%TYPE;
	BEGIN
		SELECT user INTO l_user FROM DUAL;	
		SELECT v_saldo_pendiente INTO lv_anterior FROM resumenpagoreserva;	
		UPDATE resumenPagoReserva SET v_saldo_pendiente = (v_saldo_pendiente - :NEW.v_valor), f_ultimo_pago = sysdate  WHERE k_reserva = :NEW.k_idReserva;
		INSERT INTO auditoria (k_id,n_usuario,f_proceso,i_tipo,n_tabla,n_columna,va_anterior,va_nuevo) 
					VALUES (auditoria_seq.NEXTVAL,l_user,sysdate,'UPDATE','RESUMENPAGORESERVA','V_SALDO_PENDIENTE',lv_anterior,lv_anterior - :NEW.v_valor);		
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR(-20400,'No se puede encontrar los datos');
END tg_updateRmenPagoR;
/
show errors

----------------------------------------------------------------
/* 
	Trigger que se encargara de comprobar si existe algun pago para el paso en el cual se desea modificar el costo
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: UPDATE
	TABLA:  paso
	COLUMNAS: v_costo	
	EXCEPTION: Si encuentra algun pago no puede cambiar el costo del paso
*/
CREATE OR REPLACE TRIGGER tg_compruebaPagosPaso
	BEFORE UPDATE OF v_costo ON paso
	FOR EACH ROW
	DECLARE
		lv_pagosRealizados number(3,0);
		le_pagoEncontrado EXCEPTION;			
	BEGIN
		SELECT COUNT(PP.k_id) INTO lv_pagosRealizados FROM pagoPaso PP WHERE PP.k_paso=:NEW.k_id;
		IF (lv_pagosRealizados > 0) THEN
			RAISE le_pagoEncontrado;
		END IF;		
	EXCEPTION
		WHEN le_pagoEncontrado THEN
			RAISE_APPLICATION_ERROR(-20700,'Ya se registra un pago para ese paso');
		WHEN VALUE_ERROR THEN
			RAISE_APPLICATION_ERROR(-20601,'No se pudo identificar el numero de pagos realizados');
END tg_compruebaPagosPaso;
/
/* 
	Si se inserta un costo en el paso:  Trigger que se encargara de crear un registro en la tabla resumenpagopaso 
										correspondiente al nuevo paso
	Si se actualiza el costo en un paso: Trigger que se encargara de actualizar el saldo pendiente para la tabla 
											resumenpagopaso
	PRE-CONDICION: No se ha realizado ningun pago para el paso
	TRIGGER TYPE: AFTER EACH ROW
	TRIGGERING EVENT: INSERT OR UPDATE
	TABLA:  paso
	COLUMNAS: v_costo
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/
CREATE OR REPLACE TRIGGER tg_insercionRmenPagoP
	AFTER INSERT OR UPDATE OF v_costo ON paso
	FOR EACH ROW
	DECLARE
		l_user varchar2(25);		
				 
		CURSOR C_columnas IS 
		  	SELECT COLUMN_NAME   FROM ALL_TAB_COLS
		  		WHERE TABLE_NAME =  'PASO' AND OWNER = 'CANALDEPANAMA';
		Rc_columna C_columnas%ROWTYPE;

		ln_columnvalue auditoria.va_nuevo%TYPE;	

		v_SQLCommand VARCHAR2(4000);				
	BEGIN
		SELECT user INTO l_user FROM DUAL;
		IF INSERTING THEN		
			INSERT INTO resumenPagoPaso (k_paso, v_saldo_pendiente, f_ultimo_pago) VALUES (:NEW.k_id, :NEW.v_costo, NULL);
			OPEN C_columnas;
			LOOP
				FETCH C_columnas INTO Rc_columna;
				EXIT WHEN C_columnas%NOTFOUND;
					ln_columnvalue := Rc_columna.COLUMN_NAME;
					INSERT INTO auditoria (k_id, n_usuario,f_proceso,i_tipo,n_tabla,n_columna,va_anterior,va_nuevo) 
					VALUES (auditoria_seq.NEXTVAL,l_user,sysdate,'INSERT','PASO',ln_columnvalue,NULL,ln_columnvalue);						
			END LOOP;
			CLOSE C_columnas;
		ELSE
			UPDATE resumenPagoPaso  SET v_saldo_pendiente=:NEW.v_costo WHERE k_paso = :NEW.k_id;
			INSERT INTO auditoria (k_id,n_usuario,f_proceso,i_tipo,n_tabla,n_columna,va_anterior,va_nuevo) 
					VALUES (auditoria_seq.NEXTVAL,l_user,sysdate,'UPDATE','PASO','V_COSTO',:OLD.V_COSTO,:NEW.V_COSTO);
		END IF;		
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
END tg_insercionRmenPagoP;
/
/* 
	Trigger que se encargara de comprobar si el pago que se desea registrar es menor a la deuda que posee el paso
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  pagoPaso
	COLUMNAS: cualquiera
	EXCEPTION:  Si el valor del pago es mayor a la deuda
				Si no encuentra un valor para la deuda
*/
CREATE OR REPLACE TRIGGER tg_comprobacionPagoPaso
	BEFORE INSERT ON pagoPaso
	FOR EACH ROW
	DECLARE
		lv_deuda resumenPagoPaso.v_saldo_pendiente%TYPE; 
		le_saldosobrepasado EXCEPTION;
	BEGIN
		SELECT PA.v_deuda INTO lv_deuda FROM pasosAgente PA WHERE PA.k_id = :NEW.k_paso;
  		IF(:NEW.v_valor > lv_deuda) THEN
  			RAISE le_saldosobrepasado;	
		END IF;
	EXCEPTION
		WHEN le_saldosobrepasado THEN
			RAISE_APPLICATION_ERROR(-20501,'El valor del saldo pendiente es menor al valor que se desea pagar');
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR(-20300,'Error al recuperar la deuda actual');
END tg_comprobacionPagoPaso;
/
/* 
	Trigger que se encargara de actualizar el saldo pendiente de la tabla resumenpagopaso una vez se ha registrado
	un pago para el paso
	TRIGGER TYPE: AFTER EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  pagoPaso
	COLUMNAS: cualquiera
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/
CREATE OR REPLACE TRIGGER tg_updateRmenPagoP
	AFTER INSERT ON pagoPaso
	FOR EACH ROW
	DECLARE
		l_user varchar2(25);
		lv_anterior resumenpagoreserva.v_saldo_pendiente%TYPE;
	BEGIN		
		SELECT user INTO l_user FROM DUAL;
		SELECT v_saldo_pendiente INTO lv_anterior FROM resumenpagoreserva;
		UPDATE resumenPagoPaso SET v_saldo_pendiente = (v_saldo_pendiente - :NEW.v_valor), f_ultimo_pago = sysdate  WHERE k_paso = :NEW.k_paso;		
		INSERT INTO auditoria (k_id,n_usuario,f_proceso,i_tipo,n_tabla,n_columna,va_anterior,va_nuevo) 
					VALUES (auditoria_seq.NEXTVAL,l_user,sysdate,'UPDATE','RESUMENPAGORESERVA','V_SALDO_PENDIENTE',lv_anterior,lv_anterior - :NEW.v_valor);
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
END tg_updateRmenPagoP;
/
show errors
/* 
	Trigger que se encargara de asegurar que el id del nuevo agente sea todo en mayusculas
	TRIGGER TYPE: BEFORE EACH ROW
	TRIGGERING EVENT: INSERT
	TABLA:  agente
	COLUMNAS: cualquiera
	EXCEPTION: Si se agota el tiempo para actualizar o insertar el registro
*/
CREATE OR REPLACE TRIGGER tg_registroAgente
	BEFORE INSERT OR UPDATE ON agente
	FOR EACH ROW
	BEGIN
		:NEW.k_id := UPPER(:NEW.k_id);
	EXCEPTION
		WHEN TIMEOUT_ON_RESOURCE THEN
			RAISE_APPLICATION_ERROR(-51,'tiempo de espera maximo alcanzado');
	
END tg_registroAgente;
/



